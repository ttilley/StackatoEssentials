{"note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","tagline":"notes, tips, and useful information","body":"My personal goal with this document is to provide a somewhat more gentle introduction to Cloud Foundry and Stackato than you might otherwise receive, as well as to shine light on components and functionality that might not be documented in sufficient detail elsewhere.\r\n\r\nIf you find any of the information here useful, you can thank me by [providing feedback](https://github.com/ttilley/StackatoEssentials/issues). *Please* feel free to fork, improve, and submit pull requests.\r\n\r\n## Core Components {#core_components}\r\n\r\n![General Architecture](http://docs.stackato.com/_images/stackato-architecture-diagram.png \"stackato general architecture\")\r\n\r\n### Doozerd {#doozerd}\r\n\r\n> Doozer is a highly-available, completely consistent store for small amounts of extremely important data. When the data changes, it can notify connected clients immediately (no polling), making it ideal for infrequently-updated data for which clients want real-time updates.  \r\n> <https://github.com/ActiveState/doozerd>\r\n\r\nDoozer is a [recent addition](http://www.activestate.com/blog/2012/08/doozer-distributed-configuration-used-heroku-and-stackato) to the stack that is unique to Stackato, replacing most configuration sources used by other implementations of Cloud Foundry. In standard Cloud Foundry one might SSH into the machine running a service to configure it (via YAML files), and restart said service to pick to those configuration changes. In Stackato you are able to configure the entire cluster from a single location and services react to configuration changes themselves. You are also able to query doozer for information on currently connected nodes.\r\n\r\n### Prealloc {#prealloc}\r\n\r\n### Stager {#stager}\r\n\r\n### DEA {#dea}\r\n\r\n### Cloud Controller {#cloud_controller}\r\n\r\nThe Cloud Controller handles all state transitions, manages users/apps/services, and provides the external REST API used by the stackato client (or VMC, should you so desire).\r\n\r\n### Health Manager {#health_manager}\r\n\r\n### Router {#router}\r\n\r\nThe router handles all HTTP traffic into the cluster and maintains distributed routing state. The router responds to realtime updates from DEA nodes. Load balancing is performed when an app has multiple instances.\r\n\r\nThere are currently two implementations of the router component in Stackato (as of 2.2). In order to make use of websockets, one must use router2g rather than the default router.\r\n\r\n### NATS {#nats}\r\n\r\nNATS is a lightweight cloud messaging system by Derek Collison, who was previously Chief Architect for TIBCO's messaging products.\r\n\r\nMessage passing, via NATS, is the foundation of the Cloud Foundry architecture. It is used for addressing and component discovery, command and control, heartbeats, and various other tasks.\r\n\r\n#### Cloud Controller Messages\r\n\r\n- Publish: dea.discover\r\n- Publish: dea.find.droplet\r\n- Publish: dea.locate\r\n- Publish: dea.start\r\n- Publish: dea.stop\r\n- Publish: dea.update\r\n- Publish: droplet.updated\r\n- Publish: healthmanager.health\r\n- Publish: healthmanager.status\r\n- Publish: router.register\r\n- Publish: router.unregister\r\n- Publish: vcap.cc.events\r\n- Publish: vcap.component.announce\r\n- Publish: vcap.stager.{queue}\r\n- Subscribe: cloudcontroller.bulk.credentials\r\n- Subscribe: cloudcontrollers.hm.requests\r\n- Subscribe: dea.advertise\r\n- Subscribe: router.start\r\n- Subscribe: vcap.component.discover\r\n\r\n#### DEA Messages\r\n\r\n- Publish: dea.advertise\r\n- Publish: dea.heartbeat\r\n- Publish: dea.start\r\n- Publish: droplet.exited\r\n- Publish: router.register\r\n- Publish: router.unregister\r\n- Publish: vcap.component.announce\r\n- Subscribe: dea.discover\r\n- Subscribe: dea.find.droplet\r\n- Subscribe: dea.locate\r\n- Subscribe: dea.status\r\n- Subscribe: dea.stop\r\n- Subscribe: dea.update\r\n- Subscribe: dea.{uuid}.start\r\n- Subscribe: droplet.status\r\n- Subscribe: healthmanager.start\r\n- Subscribe: router.start\r\n- Subscribe: vcap.component.discover\r\n\r\n#### Health Manager Messages\r\n\r\n- Publish: cloudcontrollers.hm.requests\r\n- Publish: healthmanager.start\r\n- Publish: vcap.component.announce\r\n- Subscribe: dea.heartbeat\r\n- Subscribe: droplet.exited\r\n- Subscribe: droplet.updated\r\n- Subscribe: healthmanager.health\r\n- Subscribe: healthmanager.status\r\n- Subscribe: vcap.component.discover\r\n\r\n#### Router Messages\r\n\r\n- Publish: router.start\r\n- Publish: vcap.component.announce\r\n- Subscribe: router.register\r\n- Subscribe: router.unregister\r\n- Subscribe: vcap.component.discover\r\n\r\n#### Stager Messages\r\n\r\n- Subscribe: vcap.stager.{queue}\r\n\r\n### Data Services {#data_services}\r\n\r\nAll data services have three subcomponents: Node, Provisioner, and Gateway. The Node implements the actual service backend. The provisioner handles various logic around provisioning and unprovisioning a specific instance of the service. The gateway provides a REST interface to the provisioner. In practice the provisioner and gateway are usually implemented as a singular daemon.\r\n\r\nPrior to Stackato 2.2, the filesystem service was a special exception to this rule. It did not have a gateway, and was assumed to exist on a singular node. This limitation has since been lifted.\r\n\r\n## Application Deployment Flow {#application_deployment_flow}\r\n\r\nThis is a shortened version of what happens when you deploy an application:\r\n\r\n1. stackato push\r\n2. framework detection\r\n3. create app in CloudController\r\n4. framework staging plugin\r\n5. droplet creation\r\n6. request DEA for app\r\n7. an available DEA node responds\r\n8. droplet is deployed to the DEA\r\n9. DEA starts the app\r\n10. upon successful start, the router creates a route\r\n\r\n## Cluster Setup {#cluster_setup}\r\n\r\n### Roles {#roles}\r\n\r\n### Fog {#fog}\r\n\r\n```ruby\r\nrequire 'rubygems'\r\nrequire 'fog'\r\n\r\nSTACKATO_V207_AMI       = \"ami-595bf530\"\r\n\r\nAWS_ACCESS_KEY_ID       = ENV[\"AWS_ACCESS_KEY_ID\"]\r\nAWS_SECRET_ACCESS_KEY   = ENV[\"AWS_SECRET_ACCESS_KEY\"]\r\nEC2_REGION              = ENV[\"EC2_REGION\"]             || \"us-east-1\"\r\nEC2_AVAILABILITY_ZONE   = ENV[\"EC2_AVAILABILITY_ZONE\"]  || \"us-east-1d\"\r\n\r\nSTACKATO_EMAIL          = ENV[\"STACKATO_EMAIL\"]         || \"stackato@stackato.local\"\r\nSTACKATO_PASSWORD       = ENV[\"STACKATO_PASSWORD\"]      || \"stackato\"\r\n\r\nconnection = Fog::Compute.new({\r\n  :provider               => :AWS,\r\n  :aws_access_key_id      => AWS_ACCESS_KEY_ID,\r\n  :aws_secret_access_key  => AWS_SECRET_ACCESS_KEY,\r\n  :region                 => EC2_REGION\r\n})\r\n\r\nserver = connection.servers.bootstrap({\r\n  :private_key_path   => \"~/.ec2/default.pem\", \r\n  :public_key_path    => \"~/.ec2/default.pem.pub\", \r\n  :availability_zone  => EC2_AVAILABILITY_ZONE, \r\n  :username           => \"ubuntu\", \r\n  :image_id           => STACKATO_V207_AMI,\r\n  :flavor_id          => \"m1.small\",\r\n  :bits               => 64\r\n})\r\n\r\nserver.ssh(<<EOF\r\ncurl -k \"https://api.$(hostname).local/stackato/license\" \\\r\n     -d \"email=#{STACKATO_EMAIL}&password=#{STACKATO_PASSWORD}&unix_password=#{STACKATO_PASSWORD}\"\r\nEOF\r\n)\r\n```\r\n\r\n### Chef {#chef}\r\n\r\n### CloudInit {#cloud_init}\r\n\r\ncloud-init is a highly configurable system for handling early initialization of a cloud instance. More information on cloud-init can be found at the [project's launchpad](https://launchpad.net/cloud-init). There is also [a screencast](http://www.youtube.com/watch?v=-zL3BdbKyGY) covering the cloud-config portion of cloud-init on the [ubuntucloud youtube channel](http://www.youtube.com/user/ubuntucloud).\r\n\r\n#### Data Sources {#cloud_init_data_sources}\r\n\r\nThe cloud-init package supports searching multiple \"Data Sources\" for information that can be used to configure a particular cloud instance. The list of potential sources is configured in the `datasource_list` key, with the first entry found to be valid becoming the data source for that run. This value, as well as any detailed configuration in `datasource`, should be set locally in `cloud.cfg` or injected early via some other means (like the kernel cmdline). Any Ubuntu based EC2 AMIs will contain EC2 as a data source by default, otherwise the list will contain `[\"NoCloud\", \"ConfigDrive\", \"OVF\", \"MAAS\"]`.\r\n\r\n*Note: If the `datasources_list` value from `/etc/cloud/cloud.cfg` is not being used, check for an `/etc/cloud/cloud.cfg.d/90_dpkg.cfg` and run `dpkg-reconfigure cloud-init` if found.*\r\n\r\nNote: Selecting the \"Ec2\" data source may result in lengthy boot times if the EC2 metadata API is unavailable. If you firewall off the metadata API for security purposes and do not wish to use it with cloud-init, make sure to edit `datasource_list`. For a convenient method of removing access to the metadata API after cloud-init has retrieved any necessary data, enable the `disable-ec2-metadata` module.\r\n\r\nIf you are using a deployment platform that provides some level of EC2 compatibility then you may want to ensure that the metadata IP (169.254.169.254) is reachable and that the HTTP endpoints (ex: /2009-04-04/meta-data/instance-id) are available ahead of time. For additional configurability, you also have the option of manually setting `metadata_urls` on the data source:\r\n\r\n```yaml\r\ndatasource:\r\n  Ec2:\r\n    metadata_urls:\r\n      - http://169.254.169.254:80\r\n      - http://instance-data:8773\r\n```\r\n\r\nWhile CloudStack provides a metadata API with similarities to the one provided by EC2, there are notable differences that make it incompatible. In particular, the metadata API will be available via the default gateway and thus cannot be sanely configured ahead of time. There is a seperate \"CloudStack\" datasource that handles these differences.\r\n\r\nValid data sources:\r\n\r\n  - **NoCloud**: reads info from `/var/lib/cloud/seed` only\r\n  - **ConfigDrive**: reads data from OpenStack Config Drive\r\n  - **OVF**: reads data from OVF Transports\r\n  - **MAAS**: reads data from Ubuntu MAAS\r\n  - **EC2**: reads data from EC2 metadata service\r\n  - **CloudStack**: reads data from CloudStack metadata service\r\n\r\n#### Frequency {#cloud_init_frequency}\r\n\r\nScripts and configuration directives may be acted upon with the following frequencies:\r\n\r\n1. once **ever**\r\n2. once per instance\r\n3. once per boot (always)\r\n\r\nYou can usually assume that the default frequency for an action is once per instance. On every run, cloud-init will check what the current \"instance id\" is and compare this value with the previously recorded id. This makes it easy to do things like clone an existing system and ensure that a base set of actions are performed when the clone comes online. You may, for example, delete any pre-existing chef configuration and re-register as a new client.\r\n\r\n*Warning: On EC2, a full shutdown will result in your VM receiving a new instance-id.*\r\n\r\nThe following modules, however, are loaded with a default frequency of \"always\":\r\n\r\n- bootcmd\r\n- disable-ec2-metadata\r\n- final-message\r\n- resizefs\r\n- scripts-per-boot\r\n- update_etc_hosts\r\n- update_hostname\r\n\r\nNote that without accompanying configuration, a module that is loaded on each boot will still have no effect on the system.\r\n\r\nIt is possible to change the run frequency of a module. Under the module section where it is defined, replace the string name with an array of `[name, frequency, arguments]`. Within this context, frequency must be named `once-per-instance`, `always`, or `once`.\r\n\r\n#### Order of Execution {#cloud_init_order_of_execution}\r\n\r\nThe cloud-init package is run in several stages during bootstrap:\r\n\r\n- root filesystem is mounted\r\n- cloud-init-local runs (**cloud-init start-local**)\r\n\t- purge any cached data and metadata\r\n\t- if a valid (non-network) data source is found then perform a normal start using that data source\r\n- all configured network interfaces come up\r\n- cloud-init runs (**cloud-init start**)\r\n\t- check the kernel cmdline for a `cloud-config-url` parameter. If present, fetch and save the content of this URL to `/etc/cloud/cloud.cfg.d/91_kernel_cmdline_url.cfg`\r\n\t- ensure /var/lib/cloud and subdirectories are created\r\n\t- set the current instance id\r\n\t- update cached user data and metadata\r\n\t- the `cloud_init_modules` value from cloud-config is read and modules are run in the order that they appear. these are, by default:\r\n\t\t1. bootcmd\r\n\t\t2. resizefs\r\n\t\t3. set_hostname\r\n\t\t4. update_hostname\r\n\t\t5. update_etc_hosts\r\n\t\t6. ca-certs\r\n\t\t7. rsyslog\r\n\t\t8. ssh\r\n- any remaining filesystems will be mounted by this point\r\n- rsyslog will be running by this point\r\n- cloud-config runs (**cloud-init-cfg all config**)\r\n\t- the `cloud_config_modules` value from cloud-config is read and modules are run in the order that they appear. these are, by default:\r\n\t\t1. mounts\r\n\t\t2. ssh-import-id\r\n\t\t3. locale\r\n\t\t4. set-passwords\r\n\t\t5. grub-dpkg\r\n\t\t6. apt-pipelining\r\n\t\t7. apt-update-upgrade\r\n\t\t8. landscape\r\n\t\t9. timezone\r\n\t\t10. puppet\r\n\t\t11. chef\r\n\t\t12. salt-minion\r\n\t\t13. mcollective\r\n\t\t14. disable-ec2-metadata\r\n\t\t15. runcmd\r\n\t\t16. byobu\r\n- all runlevel rc scripts run\r\n- cloud-final runs (**cloud-init-cfg all final**)\r\n\t- the `cloud_final_modules` value from cloud-config is read and modules are run in the order that they appear. these are, by default:\r\n\t\t1. rightscale_userdata\r\n\t\t2. scripts-per-once\r\n\t\t3. scripts-per-boot\r\n\t\t4. scripts-per-instance\r\n\t\t5. scripts-user\r\n\t\t6. keys-to-console\r\n\t\t7. phone-home\r\n\t\t8. final-message\r\n\r\n#### risks {#risks}\r\n\r\nPlease be aware that the metadata service has no concept of access control. An application running on a DEA node has the same level of access to your metadata as anything else running on that machine. There are multiple methods of hiding sensitive information from prying eyes, such as include-once directives that point to single-use URLs. The easiest method by far, however, is enabling the `disable_ec2_metadata` option in your cloud-config. The disable_ec2_metadata module will run the following: `route add -host 169.254.169.254 reject`.\r\n\r\n## Monitoring {#monitoring}\r\n\r\n### Ganglia {#ganglia}\r\n\r\n## Auto-Scaling {#auto_scaling}\r\n\r\n## Troubleshooting {#troubleshooting}\r\n\r\n### Application Crash {#application_crash}\r\n\r\nIf an application crashes, the linux container for that app sticks around for about an hour by default before getting cleaned up. This allows you to ssh into the container and perform any necessary debugging. Logs will also be available to you this way, even if they are not directly available via the dashboard any longer.\r\n\r\n>Note: you can access an app as it's owner, or as an admin with the --group='owner@email' option to the stackato CLI. The way option ordering works, the group option must come before the ssh command:\r\n>````\r\n>stackato --group='owner@email.com' ssh appname\r\n>````\r\n\r\nIn the scenario of an application crash:\r\n\r\n1. The DEA node detects the unexpected exit and broadcasts a message to NATS\r\n2. Routers remove the crashed app from the routing table\r\n3. The Health Manager notifies the Cloud Controller\r\n4. The Cloud Controller re-starts the instance\r\n\r\n### DEA Crash {#dea_crash}\r\n\r\nIn the scenario of a DEA node crash:\r\n\r\n1. Applications handled by the DEA become unavailable\r\n2. The Health Manager notices the missing instances and notifies the Cloud Controller\r\n3. The Cloud Controller requests DEA nodes for the apps\r\n4. As DEA nodes reply, application instances will be started on these new DEA nodes\r\n\r\nNote that as part of the Prealloc/DEA init that occurs when starting the DEA service, previously existing linux containers are cleaned up and removed. If you need any of that data for debugging or analysis then you will want to copy it to another location than /lxc/containers or /mnt/lxc/containers.\r\n\r\n### Inotify\r\n\r\n````\r\nfs.inotify.max_user_instances = 4096\r\nfs.inotify.max_user_watches = 32768\r\nfs.inotify.max_queued_events = 65536\r\n````\r\n","name":"Stackato Essentials"}